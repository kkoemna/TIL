# 2の補数を得る式
## 問題
負数を2の補数で表すとき，8ビットの2進正数nに対し－nを求める式はどれか。ここで，＋は加算を表し，ORはビットごとの論理和，XORはビットごとの排他的論理和を表す。

ア：(n OR 10000000)＋00000001

イ：(n OR 11111110)＋11111111

ウ：(n XOR 10000000)＋11111111

エ：(n XOR 11111111)＋00000001

## 解答
エ：(n XOR 11111111)＋00000001

## 解説
2の補数とは、負数を表現する方法の一つ。ある正数に対応する2の補数を求めるには、すべてのビットを反転して1を加える。<br>
この全ビットを反転するときに使われる論理演算が排他的論理和(XOR)。排他的論理和には次のような特徴がある。

- 「XOR 0（0との排他的論理和）」の結果は元のビットそのままとなる
- 「XOR 1（1との排他的論理和）」の結果は元のビットを反転したビットとなる（0→1、1→0）

この性質を生かして、排他的論理和はあるビット列中で特定の部分だけを反転させるときに用いられる。

2進正数nから2の補数表現の－nを得るには、

① nの全ビットを反転する ⇒ n XOR 11111111
② ①の結果に1を加算する ⇒ ＋00000001

という演算を行うことになるため、上記2つの演算を組み合わせた「(n XOR 11111111)＋00000001」が正しい式となる。

# 基数変換の流れ図
## 問題
次の流れ図は，10進整数j(0＜j＜100)を8桁の2進数に変換する処理を表している。2進数は下位桁から順に，配列の要素NISHIN(1)からNISHIN(8)に格納される。流れ図のa及びbに入れる処理はどれか。ここで，j div 2はjを2で割った商の整数部分を，j mod 2はjを2で割った余りを表す。

![02](https://user-images.githubusercontent.com/115250897/231308979-4ddd7037-e75e-418d-8be8-0d4f163449ae.gif)

![02a](https://user-images.githubusercontent.com/115250897/231309048-125faa26-26b1-417a-8498-433c4fb4f198.gif)

## 解答
エ

## 解説
例として`j=50`のときに各配列要素に格納される値の違いを見ていく。

NISHIN[1] が最下位ビット(一番右)、NISHIN[8] が最上位ビット(一番左)で下位ビットから順番に値を格納していく。

10進数50は「32＋16＋2＝2の5乗＋2の４乗＋2の１乗」なので、2進数8ビットだと 0011 0010 と表せる。流れ図の処理でも、aとbを繰り返して同様に変換されるかどうかを確認していくことで、正しい解を導くことができる。

エ
```
[a] 50 mod 2 = 0 → NISHIN[1]
[b] 50 div 2 = 25 → j
[a] 25 mod 2 = 1 → NISHIN[2]
[b] 25 div 2 = 12 → j
[a] 12 mod 2 = 0 → NISHIN[3]
[b] 12 div 2 = 6 → j
[a] 6 mod 2 = 0 → NISHIN[4]
[b] 6 div 2 = 3 → j
[a] 3 mod 2 = 1 → NISHIN[5]
[b] 3 div 2 = 1 → j
[a] 1 mod 2 = 1 → NISHIN[6]
[b] 1 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[7]
[b] 0 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[8]
[b] 0 div 2 = 0 → j
```

この時点でkが8になりループが終了する。NISHIN(1)が最下位桁、NISHIN(8)が最上位桁のため、上位桁から順番に 0011 0010 が格納されていることになる。

# 命題の真理値
## 問題
P，Q，Rはいずれも命題である。命題Pの真理値は真であり，命題 (not P) or Q 及び命題 (not Q) or R のいずれの真理値も真であることが分かっている。Q，Rの真理値はどれか。ここで，X or Y は X と Y の論理和，not X は X の否定を表す。

![03](https://user-images.githubusercontent.com/115250897/231596414-f0308cb0-4df4-489c-8e28-a4644a31d793.gif)

## 解答
エ

## 解説
「命題」とは、真か偽のどちらかであるという性質を持つ文のこと。例えば、「明日は晴れる」、「1 + 1 = 2」、「東京は日本の首都である」などは命題と言える。<br>
「真理値」とは、命題が真か偽かを表す値のこと。真理値は常に真または偽のどちらか。例えば、「明日は晴れる」という命題の真理値は、明日が晴れる場合には真、そうでない場合には偽となる。

命題Pが真とわかってるので、まずPが含まれている「(not P) or Q＝真」について考える。

Pが真なので「not P＝偽」である。よって、この命題は「偽 or Q＝真」と書き換えることができる。論理和演算(or演算)の特徴を考えると「偽 or Q＝真」を満たすためにはQが真でなければならないので、命題Qは真ということがわかる。

次に「(not Q) or R＝真」について考える。Qが真なので「not Q＝偽」になり、この命題は「偽 or R＝真」と書き換えることができる。先程と同様に論理和演算の特徴から、この命題を満たすためには命題Rは真でなくてはならない。

これらをまとめるとQ、Rはいずれも真ということになるので、正しい組合せは「エ」。

# 有限オートマトン
## 問題
入力記号，出力記号の集合が{0，1}であり，状態遷移図で示されるオートマトンがある。0011001110 を入力記号とした場合の出力記号はどれか。ここで，入力記号は左から順に読み込まれるものとする。また，S1は初期状態を表し，遷移の矢印のラベルは，入力／出力を表している。

![04](https://user-images.githubusercontent.com/115250897/231976283-51c598cc-be16-41cd-832f-d72de730a1ff.gif)

ア：0001000110

イ：0001001110

ウ：0010001000

エ：0011111110

## 解答
ア

## 解説
オートマトンは、現在の状態と入力信号の組合せのみによって次に遷移する状態が決まるモデルのこと。

設問の図の初期状態S1を例にすると、入力信号が0であれば再度S1に遷移し、入力信号が1であればS2に遷移する。

設問のオートマトンに 0011001110 の順に入力すると、以下のように遷移する。

![04a](https://user-images.githubusercontent.com/115250897/231985041-2eb36b6d-191f-4706-b9e6-64c76df37edf.gif)

たどった順に遷移するときの出力（a／bの右側）を順に並べると、0001000110 になる。したがって「ア」が正解。

# 2分探索木になっている2分木
## 問題
2分探索木になっている2分木はどれか。

ア：
![05a](https://user-images.githubusercontent.com/115250897/232180252-47055730-b127-4a0c-95f0-d6a5731bb716.gif)

イ：
![05i](https://user-images.githubusercontent.com/115250897/232180312-1de2a34b-a2a6-440e-be89-41741c772f93.gif)

ウ：
![05u](https://user-images.githubusercontent.com/115250897/232180315-b4db3120-1879-469a-923c-71ada61ca68d.gif)

エ：
![05e](https://user-images.githubusercontent.com/115250897/232180318-44cf4e9a-2139-4e49-8eda-32ad90146d70.gif)

## 解答
イ

## 解説
2分探索木は、2分木（各節から出る枝の数が2本以下になっている木）の各節にデータをもたせることで探索を行えるようにした木のこと。

各節がもつデータは`その節から出る左部分木にあるどのデータよりも大きく、右部分木のどのデータよりも小さい`という条件がある。

要するに、どの部分を見ても`左 < 中 < 右`の関係を満たしていれば2分探索木といえるということ。

最も簡単に見分ける方法は、図示されている木構造の各節点を左から順に並べて、昇順になっているか否かを確認すること。

ちなみに、2分探索木のアルゴリズムは、以下のとおり。

1. 根から探索を始める
2. 探索対象の値が現在の節の値よりも小さい場合、左部分木に進む
3. 探索対象の値が現在の節の値よりも大きい場合、右部分木に進む
4. 探索対象の値が現在の節の値と等しい場合、その節を返す

データの検索・挿入・削除が効率的におこなえるので、大量のデータを高速に処理するような実装に使われる。

# 図形回転アルゴリズム
## 問題
配列Aが図2の状態のとき，図1の流れ図を実行すると，配列Bが図3の状態になった。図1のaに入れる操作はどれか。ここで，配列A，Bの要素をそれぞれ A(i，j)，B(i，j) とする。

![06](https://user-images.githubusercontent.com/115250897/232248276-7c7eb1ca-ca9c-42aa-83ff-691b4594669f.gif)

ア：B(7－i，7－j) ← A(i，j)

イ：B(7－j，i) ← A(i，j)

ウ：B(i，7－j) ← A(i，j)

エ：B(j，7－i) ← A(i，j)

## 解答
エ

## 解説
配列Aの値が配列Bのどの位置に移動しているかを、配列中の適当な場所でサンプルを取ってみるとわかりやすい。ここでは赤丸で印をつけた一点について考える。

![06a](https://user-images.githubusercontent.com/115250897/232248388-0ce1f610-222f-4b19-adaa-c356fac9067f.gif)

この位置を配列の添え字[i，j]を使って表すと、配列Aが[3，1]、配列Bが[1，4]となる。

選択肢を見ると、配列A[i，j]を配列Bのどこに移動するかを問われているので、iが3、jが1の場合に、配列Bの位置が[1，4]となる選択肢を探す。

エ：B(1，7－3)＝B(1，4)となり適切な位置に値を移動することができる。したがってエが正解。


