# 2の補数を得る式
## 問題
負数を2の補数で表すとき，8ビットの2進正数nに対し－nを求める式はどれか。ここで，＋は加算を表し，ORはビットごとの論理和，XORはビットごとの排他的論理和を表す。

ア：(n OR 10000000)＋00000001

イ：(n OR 11111110)＋11111111

ウ：(n XOR 10000000)＋11111111

エ：(n XOR 11111111)＋00000001

## 解答
エ：(n XOR 11111111)＋00000001

## 解説
2の補数とは、負数を表現する方法の一つ。ある正数に対応する2の補数を求めるには、すべてのビットを反転して1を加える。<br>
この全ビットを反転するときに使われる論理演算が排他的論理和(XOR)。排他的論理和には次のような特徴がある。

- 「XOR 0（0との排他的論理和）」の結果は元のビットそのままとなる
- 「XOR 1（1との排他的論理和）」の結果は元のビットを反転したビットとなる（0→1、1→0）

この性質を生かして、排他的論理和はあるビット列中で特定の部分だけを反転させるときに用いられる。

2進正数nから2の補数表現の－nを得るには、

① nの全ビットを反転する ⇒ n XOR 11111111
② ①の結果に1を加算する ⇒ ＋00000001

という演算を行うことになるため、上記2つの演算を組み合わせた「(n XOR 11111111)＋00000001」が正しい式となる。

# 基数変換の流れ図
## 問題
次の流れ図は，10進整数j(0＜j＜100)を8桁の2進数に変換する処理を表している。2進数は下位桁から順に，配列の要素NISHIN(1)からNISHIN(8)に格納される。流れ図のa及びbに入れる処理はどれか。ここで，j div 2はjを2で割った商の整数部分を，j mod 2はjを2で割った余りを表す。

![02](https://user-images.githubusercontent.com/115250897/231308979-4ddd7037-e75e-418d-8be8-0d4f163449ae.gif)

![02a](https://user-images.githubusercontent.com/115250897/231309048-125faa26-26b1-417a-8498-433c4fb4f198.gif)

## 解答
エ

## 解説
例として`j=50`のときに各配列要素に格納される値の違いを見ていく。

NISHIN[1] が最下位ビット(一番右)、NISHIN[8] が最上位ビット(一番左)で下位ビットから順番に値を格納していく。

10進数50は「32＋16＋2＝2の5乗＋2の４乗＋2の１乗」なので、2進数8ビットだと 0011 0010 と表せる。流れ図の処理でも、aとbを繰り返して同様に変換されるかどうかを確認していくことで、正しい解を導くことができる。

エ
```
[a] 50 mod 2 = 0 → NISHIN[1]
[b] 50 div 2 = 25 → j
[a] 25 mod 2 = 1 → NISHIN[2]
[b] 25 div 2 = 12 → j
[a] 12 mod 2 = 0 → NISHIN[3]
[b] 12 div 2 = 6 → j
[a] 6 mod 2 = 0 → NISHIN[4]
[b] 6 div 2 = 3 → j
[a] 3 mod 2 = 1 → NISHIN[5]
[b] 3 div 2 = 1 → j
[a] 1 mod 2 = 1 → NISHIN[6]
[b] 1 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[7]
[b] 0 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[8]
[b] 0 div 2 = 0 → j
```

この時点でkが8になりループが終了する。NISHIN(1)が最下位桁、NISHIN(8)が最上位桁のため、上位桁から順番に 0011 0010 が格納されていることになる。
