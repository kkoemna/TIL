# 2の補数を得る式
## 問題
負数を2の補数で表すとき，8ビットの2進正数nに対し－nを求める式はどれか。ここで，＋は加算を表し，ORはビットごとの論理和，XORはビットごとの排他的論理和を表す。

ア：(n OR 10000000)＋00000001

イ：(n OR 11111110)＋11111111

ウ：(n XOR 10000000)＋11111111

エ：(n XOR 11111111)＋00000001

## 解答
エ：(n XOR 11111111)＋00000001

## 解説
2の補数とは、負数を表現する方法の一つ。ある正数に対応する2の補数を求めるには、すべてのビットを反転して1を加える。<br>
この全ビットを反転するときに使われる論理演算が排他的論理和(XOR)。排他的論理和には次のような特徴がある。

- 「XOR 0（0との排他的論理和）」の結果は元のビットそのままとなる
- 「XOR 1（1との排他的論理和）」の結果は元のビットを反転したビットとなる（0→1、1→0）

この性質を生かして、排他的論理和はあるビット列中で特定の部分だけを反転させるときに用いられる。

2進正数nから2の補数表現の－nを得るには、

① nの全ビットを反転する ⇒ n XOR 11111111
② ①の結果に1を加算する ⇒ ＋00000001

という演算を行うことになるため、上記2つの演算を組み合わせた「(n XOR 11111111)＋00000001」が正しい式となる。

# 基数変換の流れ図
## 問題
次の流れ図は，10進整数j(0＜j＜100)を8桁の2進数に変換する処理を表している。2進数は下位桁から順に，配列の要素NISHIN(1)からNISHIN(8)に格納される。流れ図のa及びbに入れる処理はどれか。ここで，j div 2はjを2で割った商の整数部分を，j mod 2はjを2で割った余りを表す。

![02](https://user-images.githubusercontent.com/115250897/231308979-4ddd7037-e75e-418d-8be8-0d4f163449ae.gif)

![02a](https://user-images.githubusercontent.com/115250897/231309048-125faa26-26b1-417a-8498-433c4fb4f198.gif)

## 解答
エ

## 解説
例として`j=50`のときに各配列要素に格納される値の違いを見ていく。

NISHIN[1] が最下位ビット(一番右)、NISHIN[8] が最上位ビット(一番左)で下位ビットから順番に値を格納していく。

10進数50は「32＋16＋2＝2の5乗＋2の４乗＋2の１乗」なので、2進数8ビットだと 0011 0010 と表せる。流れ図の処理でも、aとbを繰り返して同様に変換されるかどうかを確認していくことで、正しい解を導くことができる。

エ
```
[a] 50 mod 2 = 0 → NISHIN[1]
[b] 50 div 2 = 25 → j
[a] 25 mod 2 = 1 → NISHIN[2]
[b] 25 div 2 = 12 → j
[a] 12 mod 2 = 0 → NISHIN[3]
[b] 12 div 2 = 6 → j
[a] 6 mod 2 = 0 → NISHIN[4]
[b] 6 div 2 = 3 → j
[a] 3 mod 2 = 1 → NISHIN[5]
[b] 3 div 2 = 1 → j
[a] 1 mod 2 = 1 → NISHIN[6]
[b] 1 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[7]
[b] 0 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[8]
[b] 0 div 2 = 0 → j
```

この時点でkが8になりループが終了する。NISHIN(1)が最下位桁、NISHIN(8)が最上位桁のため、上位桁から順番に 0011 0010 が格納されていることになる。

# 命題の真理値
## 問題
P，Q，Rはいずれも命題である。命題Pの真理値は真であり，命題 (not P) or Q 及び命題 (not Q) or R のいずれの真理値も真であることが分かっている。Q，Rの真理値はどれか。ここで，X or Y は X と Y の論理和，not X は X の否定を表す。

![03](https://user-images.githubusercontent.com/115250897/231596414-f0308cb0-4df4-489c-8e28-a4644a31d793.gif)

## 解答
エ

## 解説
「命題」とは、真か偽のどちらかであるという性質を持つ文のこと。例えば、「明日は晴れる」、「1 + 1 = 2」、「東京は日本の首都である」などは命題と言える。<br>
「真理値」とは、命題が真か偽かを表す値のこと。真理値は常に真または偽のどちらか。例えば、「明日は晴れる」という命題の真理値は、明日が晴れる場合には真、そうでない場合には偽となる。

命題Pが真とわかってるので、まずPが含まれている「(not P) or Q＝真」について考える。

Pが真なので「not P＝偽」である。よって、この命題は「偽 or Q＝真」と書き換えることができる。論理和演算(or演算)の特徴を考えると「偽 or Q＝真」を満たすためにはQが真でなければならないので、命題Qは真ということがわかる。

次に「(not Q) or R＝真」について考える。Qが真なので「not Q＝偽」になり、この命題は「偽 or R＝真」と書き換えることができる。先程と同様に論理和演算の特徴から、この命題を満たすためには命題Rは真でなくてはならない。

これらをまとめるとQ、Rはいずれも真ということになるので、正しい組合せは「エ」。

# 有限オートマトン
## 問題
入力記号，出力記号の集合が{0，1}であり，状態遷移図で示されるオートマトンがある。0011001110 を入力記号とした場合の出力記号はどれか。ここで，入力記号は左から順に読み込まれるものとする。また，S1は初期状態を表し，遷移の矢印のラベルは，入力／出力を表している。

![04](https://user-images.githubusercontent.com/115250897/231976283-51c598cc-be16-41cd-832f-d72de730a1ff.gif)

ア：0001000110

イ：0001001110

ウ：0010001000

エ：0011111110

## 解答
ア

## 解説
オートマトンは、現在の状態と入力信号の組合せのみによって次に遷移する状態が決まるモデルのこと。

設問の図の初期状態S1を例にすると、入力信号が0であれば再度S1に遷移し、入力信号が1であればS2に遷移する。

設問のオートマトンに 0011001110 の順に入力すると、以下のように遷移する。

![04a](https://user-images.githubusercontent.com/115250897/231985041-2eb36b6d-191f-4706-b9e6-64c76df37edf.gif)

たどった順に遷移するときの出力（a／bの右側）を順に並べると、0001000110 になる。したがって「ア」が正解。

# 2分探索木になっている2分木
## 問題
2分探索木になっている2分木はどれか。

ア：
![05a](https://user-images.githubusercontent.com/115250897/232180252-47055730-b127-4a0c-95f0-d6a5731bb716.gif)

イ：
![05i](https://user-images.githubusercontent.com/115250897/232180312-1de2a34b-a2a6-440e-be89-41741c772f93.gif)

ウ：
![05u](https://user-images.githubusercontent.com/115250897/232180315-b4db3120-1879-469a-923c-71ada61ca68d.gif)

エ：
![05e](https://user-images.githubusercontent.com/115250897/232180318-44cf4e9a-2139-4e49-8eda-32ad90146d70.gif)

## 解答
イ

## 解説
2分探索木は、2分木（各節から出る枝の数が2本以下になっている木）の各節にデータをもたせることで探索を行えるようにした木のこと。

各節がもつデータは`その節から出る左部分木にあるどのデータよりも大きく、右部分木のどのデータよりも小さい`という条件がある。

要するに、どの部分を見ても`左 < 中 < 右`の関係を満たしていれば2分探索木といえるということ。

最も簡単に見分ける方法は、図示されている木構造の各節点を左から順に並べて、昇順になっているか否かを確認すること。

ちなみに、2分探索木のアルゴリズムは、以下のとおり。

1. 根から探索を始める
2. 探索対象の値が現在の節の値よりも小さい場合、左部分木に進む
3. 探索対象の値が現在の節の値よりも大きい場合、右部分木に進む
4. 探索対象の値が現在の節の値と等しい場合、その節を返す

データの検索・挿入・削除が効率的におこなえるので、大量のデータを高速に処理するような実装に使われる。

# 図形回転アルゴリズム
## 問題
配列Aが図2の状態のとき，図1の流れ図を実行すると，配列Bが図3の状態になった。図1のaに入れる操作はどれか。ここで，配列A，Bの要素をそれぞれ A(i，j)，B(i，j) とする。

![06](https://user-images.githubusercontent.com/115250897/232248276-7c7eb1ca-ca9c-42aa-83ff-691b4594669f.gif)

ア：B(7－i，7－j) ← A(i，j)

イ：B(7－j，i) ← A(i，j)

ウ：B(i，7－j) ← A(i，j)

エ：B(j，7－i) ← A(i，j)

## 解答
エ

## 解説
配列Aの値が配列Bのどの位置に移動しているかを、配列中の適当な場所でサンプルを取ってみるとわかりやすい。ここでは赤丸で印をつけた一点について考える。

![06a](https://user-images.githubusercontent.com/115250897/232248388-0ce1f610-222f-4b19-adaa-c356fac9067f.gif)

この位置を配列の添え字[i，j]を使って表すと、配列Aが[3，1]、配列Bが[1，4]となる。

選択肢を見ると、配列A[i，j]を配列Bのどこに移動するかを問われているので、iが3、jが1の場合に、配列Bの位置が[1，4]となる選択肢を探す。

エ：B(1，7－3)＝B(1，4)となり適切な位置に値を移動することができる。したがってエが正解。

# ハッシュ法
## 問題
10進法で5桁の数 a1a2a3a4a5 をハッシュ法を用いて配列に格納したい。ハッシュ関数を mod(a1＋a2＋a3＋a4＋a5，13) とし，求めたハッシュ値に対応する位置の配列要素に格納する場合，54321は配列のどの位置に入るか。ここで，mod(x，13) は，xを13で割った余りとする。

![07](https://user-images.githubusercontent.com/115250897/232437285-6dcc6ec5-167a-4008-b36a-ca86345db3d0.gif)

ア：1

イ：2

ウ：7

エ：11

## 解答
イ

## 解説
ハッシュ法とは、ハッシュ関数（引数を一定の規則で変換した値を返す関数）を用いて、探索するデータのキー値からデータの格納アドレスを直接計算する方法。データの格納場所が一意に決まるため挿入、検索、削除が高速に行える反面、格納に必要なデータ領域が多く必要という特徴がある。

この設問ではハッシュ関数が`mod(a1＋a2＋a3＋a4＋a5，13)`であり、a1＝5、a2＝4、…、a5＝1というように54321の各桁が対応するので、式に代入して得られる結果を計算する。mod()は、第1引数を第2引数で割った余りを返す。

```
mod(5＋4＋3＋2＋1，13)＝mod(15，13)＝2
```

したがって、データ`54321`が格納されるのは配列中の`2`の位置となる。

# 再帰関数の値はどれか
## 問題
自然数nに対して，次のとおり再帰的に定義される関数ƒ(n)を考える。ƒ(5)の値はどれか。

```
　ƒ(n)：if n≦1 then return 1 else return n＋ƒ(n－1)
```

ア：6

イ：9

ウ：15

エ：25

## 解答
ウ

## 解説
再帰関数は、関数内に自分自身の呼び出しが含まれている関数のこと。

設問の再帰関数 ƒ(n) は以下のような処理を行う。

引数nが1以下のとき

```
1を返す
```

それ以外の場合

```
n＋ƒ(n－1)を返す
```

ƒ(n)の部分を展開しながら地道に計算していくと以下のようになる。

```
　ƒ(5)

＝5＋ƒ(4)　//ƒ(5)=5＋ƒ(4)

＝5＋4＋ƒ(3)　//ƒ(4)=4＋ƒ(3)

＝5＋4＋3＋ƒ(2)　//ƒ(3)=3＋ƒ(2)

＝5＋4＋3＋2＋ƒ(1)　//ƒ(2)=2＋ƒ(1)

＝5＋4＋3＋2＋1　//ƒ(1)=1

＝15
```

したがって、ƒ(5)の値は15となる。

# コーディング規約に規定する事項
## 問題
プログラムのコーディング規約に規定する事項のうち，適切なものはどれか。

ア：局所変数は，用途が異なる場合でもデータ型が同じならば，できるだけ同一の変数を使うようにする。

イ：処理性能を向上させるために，ループの制御変数には浮動小数点型変数を使用する。

ウ：同様の計算を何度も繰り返すときは，関数の再帰呼出しを用いる。

エ：領域割付け関数を使用するときは，割付けができなかったときの処理を記述する。

## 解答
エ

## 解説
ア：1つの変数の役割は1つにするのが原則。用途が異なる場合には別々の変数として定義し、用途がわかるように適切な命名を行う。

イ：ループの制御変数には整数型を用いるのが原則。ループの制御変数に浮動小数点型変数(float等)を用いると、インクリメントやデクリメントの際の誤差が積み重なり、期待した結果を得られないことがある。

ウ：同様の処理を繰り返すときには、その処理をサブルーチン化して独立した関数にすることを検討する。再帰関数は、処理がわかりにくくなることや実行時のスタックサイズが予測できずオーバフローを起こす可能性があるので、コーディング規約で使用を禁止されることもある。

エ：領域割付け関数は必ず成功するとは限らない。もしメモリブロックを確保できないまま後続の処理に進むとそこでエラーになってしまうため、領域割付け関数の戻り値をチェックするなどして割付け失敗時の分岐処理を記述する。

# 外部割込みの原因となるもの
## 問題
外部割込みの原因となるものはどれか。

ア：ゼロによる除算命令の実行

イ：存在しない命令コードの実行

ウ：タイマによる時間経過の通知

エ：ページフォールトの発生

## 解答
ウ

## 解説
割込みは、システムにすぐに対処しなくてはならない問題などが生じたときに、実行中のプログラムの処理を強制的に停止し、優先的に事象の解決を図ることを可能にする仕組みのこと。

割込みは、実行中のプログラムが原因でCPU内部で発生する内部割込みと、それ以外の（CPU外部で発生する）外部割込みに分類することができる。

### 内部割込み

実行中のプログラムが原因で起こる割込み
- プログラム割込み
- スーパーバイザコール割込み（プログラムからOSへの処理依頼）
- ページフォールト割込み

### 外部割込み

内部割込み以外の原因で起こる割込み
- 機械チェック割込み
- タイマ割込み
- 入出力割込み

ア：ゼロによる除算は、解が無限になるため不正な処理として扱われる。ゼロによる除算は、処理中のプログラムによって引き起こされる割込み（プログラム割込み）のため、内部割込みに分類される。

イ：実行中のプログラムが原因で発生する割込みのため、内部割込みに分類される。

ウ：タイマ割込みは、システムに設定されたタイマが所定時間を経過したときに発生する割込みで、外部割込みに分類される。

エ：ページフォールト割込みは、プログラムが主記憶上に存在しないデータにアクセスしようとしたときに発生する割込みで、内部割込みに分類される。

# 必要な冗長ビットは何ビットか

## 問題
メモリのエラー検出及び訂正にECCを利用している。データバス幅2のn乗ビットに対して冗長ビットがn＋2ビット必要なとき，128ビットのデータバス幅に必要な冗長ビットは何ビットか。

ア：7

イ：8

ウ：9

エ：10

## 解答
ウ

## 解説
まず、`2のn乗ビット`と`128ビット`との対応を考える。"128は2の何乗なのか"を考えると「128＝2の7乗」なので、`nは7`とわかる。冗長ビットは、2のn乗ビットに対して n＋2ビット必要なので、2の7乗＝128ビットのデータバス幅に必要な冗長ビットは「7＋2＝9ビット」となる。　したがって「ウ」が正解。




