# 2の補数を得る式
## 問題
負数を2の補数で表すとき，8ビットの2進正数nに対し－nを求める式はどれか。ここで，＋は加算を表し，ORはビットごとの論理和，XORはビットごとの排他的論理和を表す。

ア：(n OR 10000000)＋00000001

イ：(n OR 11111110)＋11111111

ウ：(n XOR 10000000)＋11111111

エ：(n XOR 11111111)＋00000001

## 解答
エ：(n XOR 11111111)＋00000001

## 解説
2の補数とは、負数を表現する方法の一つ。ある正数に対応する2の補数を求めるには、すべてのビットを反転して1を加える。<br>
この全ビットを反転するときに使われる論理演算が排他的論理和(XOR)。排他的論理和には次のような特徴がある。

- 「XOR 0（0との排他的論理和）」の結果は元のビットそのままとなる
- 「XOR 1（1との排他的論理和）」の結果は元のビットを反転したビットとなる（0→1、1→0）

この性質を生かして、排他的論理和はあるビット列中で特定の部分だけを反転させるときに用いられる。

2進正数nから2の補数表現の－nを得るには、

① nの全ビットを反転する ⇒ n XOR 11111111
② ①の結果に1を加算する ⇒ ＋00000001

という演算を行うことになるため、上記2つの演算を組み合わせた「(n XOR 11111111)＋00000001」が正しい式となる。

# 基数変換の流れ図
## 問題
次の流れ図は，10進整数j(0＜j＜100)を8桁の2進数に変換する処理を表している。2進数は下位桁から順に，配列の要素NISHIN(1)からNISHIN(8)に格納される。流れ図のa及びbに入れる処理はどれか。ここで，j div 2はjを2で割った商の整数部分を，j mod 2はjを2で割った余りを表す。

![02](https://user-images.githubusercontent.com/115250897/231308979-4ddd7037-e75e-418d-8be8-0d4f163449ae.gif)

![02a](https://user-images.githubusercontent.com/115250897/231309048-125faa26-26b1-417a-8498-433c4fb4f198.gif)

## 解答
エ

## 解説
例として`j=50`のときに各配列要素に格納される値の違いを見ていく。

NISHIN[1] が最下位ビット(一番右)、NISHIN[8] が最上位ビット(一番左)で下位ビットから順番に値を格納していく。

10進数50は「32＋16＋2＝2の5乗＋2の４乗＋2の１乗」なので、2進数8ビットだと 0011 0010 と表せる。流れ図の処理でも、aとbを繰り返して同様に変換されるかどうかを確認していくことで、正しい解を導くことができる。

エ
```
[a] 50 mod 2 = 0 → NISHIN[1]
[b] 50 div 2 = 25 → j
[a] 25 mod 2 = 1 → NISHIN[2]
[b] 25 div 2 = 12 → j
[a] 12 mod 2 = 0 → NISHIN[3]
[b] 12 div 2 = 6 → j
[a] 6 mod 2 = 0 → NISHIN[4]
[b] 6 div 2 = 3 → j
[a] 3 mod 2 = 1 → NISHIN[5]
[b] 3 div 2 = 1 → j
[a] 1 mod 2 = 1 → NISHIN[6]
[b] 1 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[7]
[b] 0 div 2 = 0 → j
[a] 0 mod 2 = 0 → NISHIN[8]
[b] 0 div 2 = 0 → j
```

この時点でkが8になりループが終了する。NISHIN(1)が最下位桁、NISHIN(8)が最上位桁のため、上位桁から順番に 0011 0010 が格納されていることになる。

# 命題の真理値
## 問題
P，Q，Rはいずれも命題である。命題Pの真理値は真であり，命題 (not P) or Q 及び命題 (not Q) or R のいずれの真理値も真であることが分かっている。Q，Rの真理値はどれか。ここで，X or Y は X と Y の論理和，not X は X の否定を表す。

![03](https://user-images.githubusercontent.com/115250897/231596414-f0308cb0-4df4-489c-8e28-a4644a31d793.gif)

## 解答
エ

## 解説
「命題」とは、真か偽のどちらかであるという性質を持つ文のこと。例えば、「明日は晴れる」、「1 + 1 = 2」、「東京は日本の首都である」などは命題と言える。<br>
「真理値」とは、命題が真か偽かを表す値のこと。真理値は常に真または偽のどちらか。例えば、「明日は晴れる」という命題の真理値は、明日が晴れる場合には真、そうでない場合には偽となる。

命題Pが真とわかってるので、まずPが含まれている「(not P) or Q＝真」について考える。

Pが真なので「not P＝偽」である。よって、この命題は「偽 or Q＝真」と書き換えることができる。論理和演算(or演算)の特徴を考えると「偽 or Q＝真」を満たすためにはQが真でなければならないので、命題Qは真ということがわかる。

次に「(not Q) or R＝真」について考える。Qが真なので「not Q＝偽」になり、この命題は「偽 or R＝真」と書き換えることができる。先程と同様に論理和演算の特徴から、この命題を満たすためには命題Rは真でなくてはならない。

これらをまとめるとQ、Rはいずれも真ということになるので、正しい組合せは「エ」。

# 有限オートマトン
## 問題
入力記号，出力記号の集合が{0，1}であり，状態遷移図で示されるオートマトンがある。0011001110 を入力記号とした場合の出力記号はどれか。ここで，入力記号は左から順に読み込まれるものとする。また，S1は初期状態を表し，遷移の矢印のラベルは，入力／出力を表している。

![04](https://user-images.githubusercontent.com/115250897/231976283-51c598cc-be16-41cd-832f-d72de730a1ff.gif)

ア：0001000110

イ：0001001110

ウ：0010001000

エ：0011111110

## 解答
ア

## 解説
オートマトンは、現在の状態と入力信号の組合せのみによって次に遷移する状態が決まるモデルのこと。

設問の図の初期状態S1を例にすると、入力信号が0であれば再度S1に遷移し、入力信号が1であればS2に遷移する。

設問のオートマトンに 0011001110 の順に入力すると、以下のように遷移する。

![04a](https://user-images.githubusercontent.com/115250897/231985041-2eb36b6d-191f-4706-b9e6-64c76df37edf.gif)

たどった順に遷移するときの出力（a／bの右側）を順に並べると、0001000110 になる。したがって「ア」が正解。

# 2分探索木になっている2分木
## 問題
2分探索木になっている2分木はどれか。

ア：
![05a](https://user-images.githubusercontent.com/115250897/232180252-47055730-b127-4a0c-95f0-d6a5731bb716.gif)

イ：
![05i](https://user-images.githubusercontent.com/115250897/232180312-1de2a34b-a2a6-440e-be89-41741c772f93.gif)

ウ：
![05u](https://user-images.githubusercontent.com/115250897/232180315-b4db3120-1879-469a-923c-71ada61ca68d.gif)

エ：
![05e](https://user-images.githubusercontent.com/115250897/232180318-44cf4e9a-2139-4e49-8eda-32ad90146d70.gif)

## 解答
イ

## 解説
2分探索木は、2分木（各節から出る枝の数が2本以下になっている木）の各節にデータをもたせることで探索を行えるようにした木のこと。

各節がもつデータは`その節から出る左部分木にあるどのデータよりも大きく、右部分木のどのデータよりも小さい`という条件がある。

要するに、どの部分を見ても`左 < 中 < 右`の関係を満たしていれば2分探索木といえるということ。

最も簡単に見分ける方法は、図示されている木構造の各節点を左から順に並べて、昇順になっているか否かを確認すること。

ちなみに、2分探索木のアルゴリズムは、以下のとおり。

1. 根から探索を始める
2. 探索対象の値が現在の節の値よりも小さい場合、左部分木に進む
3. 探索対象の値が現在の節の値よりも大きい場合、右部分木に進む
4. 探索対象の値が現在の節の値と等しい場合、その節を返す

データの検索・挿入・削除が効率的におこなえるので、大量のデータを高速に処理するような実装に使われる。

# 図形回転アルゴリズム
## 問題
配列Aが図2の状態のとき，図1の流れ図を実行すると，配列Bが図3の状態になった。図1のaに入れる操作はどれか。ここで，配列A，Bの要素をそれぞれ A(i，j)，B(i，j) とする。

![06](https://user-images.githubusercontent.com/115250897/232248276-7c7eb1ca-ca9c-42aa-83ff-691b4594669f.gif)

ア：B(7－i，7－j) ← A(i，j)

イ：B(7－j，i) ← A(i，j)

ウ：B(i，7－j) ← A(i，j)

エ：B(j，7－i) ← A(i，j)

## 解答
エ

## 解説
配列Aの値が配列Bのどの位置に移動しているかを、配列中の適当な場所でサンプルを取ってみるとわかりやすい。ここでは赤丸で印をつけた一点について考える。

![06a](https://user-images.githubusercontent.com/115250897/232248388-0ce1f610-222f-4b19-adaa-c356fac9067f.gif)

この位置を配列の添え字[i，j]を使って表すと、配列Aが[3，1]、配列Bが[1，4]となる。

選択肢を見ると、配列A[i，j]を配列Bのどこに移動するかを問われているので、iが3、jが1の場合に、配列Bの位置が[1，4]となる選択肢を探す。

エ：B(1，7－3)＝B(1，4)となり適切な位置に値を移動することができる。したがってエが正解。

# ハッシュ法
## 問題
10進法で5桁の数 a1a2a3a4a5 をハッシュ法を用いて配列に格納したい。ハッシュ関数を mod(a1＋a2＋a3＋a4＋a5，13) とし，求めたハッシュ値に対応する位置の配列要素に格納する場合，54321は配列のどの位置に入るか。ここで，mod(x，13) は，xを13で割った余りとする。

![07](https://user-images.githubusercontent.com/115250897/232437285-6dcc6ec5-167a-4008-b36a-ca86345db3d0.gif)

ア：1

イ：2

ウ：7

エ：11

## 解答
イ

## 解説
ハッシュ法とは、ハッシュ関数（引数を一定の規則で変換した値を返す関数）を用いて、探索するデータのキー値からデータの格納アドレスを直接計算する方法。データの格納場所が一意に決まるため挿入、検索、削除が高速に行える反面、格納に必要なデータ領域が多く必要という特徴がある。

この設問ではハッシュ関数が`mod(a1＋a2＋a3＋a4＋a5，13)`であり、a1＝5、a2＝4、…、a5＝1というように54321の各桁が対応するので、式に代入して得られる結果を計算する。mod()は、第1引数を第2引数で割った余りを返す。

```
mod(5＋4＋3＋2＋1，13)＝mod(15，13)＝2
```

したがって、データ`54321`が格納されるのは配列中の`2`の位置となる。

# 再帰関数の値はどれか
## 問題
自然数nに対して，次のとおり再帰的に定義される関数ƒ(n)を考える。ƒ(5)の値はどれか。

```
　ƒ(n)：if n≦1 then return 1 else return n＋ƒ(n－1)
```

ア：6

イ：9

ウ：15

エ：25

## 解答
ウ

## 解説
再帰関数は、関数内に自分自身の呼び出しが含まれている関数のこと。

設問の再帰関数 ƒ(n) は以下のような処理を行う。

引数nが1以下のとき

```
1を返す
```

それ以外の場合

```
n＋ƒ(n－1)を返す
```

ƒ(n)の部分を展開しながら地道に計算していくと以下のようになる。

```
　ƒ(5)

＝5＋ƒ(4)　//ƒ(5)=5＋ƒ(4)

＝5＋4＋ƒ(3)　//ƒ(4)=4＋ƒ(3)

＝5＋4＋3＋ƒ(2)　//ƒ(3)=3＋ƒ(2)

＝5＋4＋3＋2＋ƒ(1)　//ƒ(2)=2＋ƒ(1)

＝5＋4＋3＋2＋1　//ƒ(1)=1

＝15
```

したがって、ƒ(5)の値は15となる。

# コーディング規約に規定する事項
## 問題
プログラムのコーディング規約に規定する事項のうち，適切なものはどれか。

ア：局所変数は，用途が異なる場合でもデータ型が同じならば，できるだけ同一の変数を使うようにする。

イ：処理性能を向上させるために，ループの制御変数には浮動小数点型変数を使用する。

ウ：同様の計算を何度も繰り返すときは，関数の再帰呼出しを用いる。

エ：領域割付け関数を使用するときは，割付けができなかったときの処理を記述する。

## 解答
エ

## 解説
ア：1つの変数の役割は1つにするのが原則。用途が異なる場合には別々の変数として定義し、用途がわかるように適切な命名を行う。

イ：ループの制御変数には整数型を用いるのが原則。ループの制御変数に浮動小数点型変数(float等)を用いると、インクリメントやデクリメントの際の誤差が積み重なり、期待した結果を得られないことがある。

ウ：同様の処理を繰り返すときには、その処理をサブルーチン化して独立した関数にすることを検討する。再帰関数は、処理がわかりにくくなることや実行時のスタックサイズが予測できずオーバフローを起こす可能性があるので、コーディング規約で使用を禁止されることもある。

エ：領域割付け関数は必ず成功するとは限らない。もしメモリブロックを確保できないまま後続の処理に進むとそこでエラーになってしまうため、領域割付け関数の戻り値をチェックするなどして割付け失敗時の分岐処理を記述する。

# 外部割込みの原因となるもの
## 問題
外部割込みの原因となるものはどれか。

ア：ゼロによる除算命令の実行

イ：存在しない命令コードの実行

ウ：タイマによる時間経過の通知

エ：ページフォールトの発生

## 解答
ウ

## 解説
割込みは、システムにすぐに対処しなくてはならない問題などが生じたときに、実行中のプログラムの処理を強制的に停止し、優先的に事象の解決を図ることを可能にする仕組みのこと。

割込みは、実行中のプログラムが原因でCPU内部で発生する内部割込みと、それ以外の（CPU外部で発生する）外部割込みに分類することができる。

### 内部割込み

実行中のプログラムが原因で起こる割込み
- プログラム割込み
- スーパーバイザコール割込み（プログラムからOSへの処理依頼）
- ページフォールト割込み

### 外部割込み

内部割込み以外の原因で起こる割込み
- 機械チェック割込み
- タイマ割込み
- 入出力割込み

ア：ゼロによる除算は、解が無限になるため不正な処理として扱われる。ゼロによる除算は、処理中のプログラムによって引き起こされる割込み（プログラム割込み）のため、内部割込みに分類される。

イ：実行中のプログラムが原因で発生する割込みのため、内部割込みに分類される。

ウ：タイマ割込みは、システムに設定されたタイマが所定時間を経過したときに発生する割込みで、外部割込みに分類される。

エ：ページフォールト割込みは、プログラムが主記憶上に存在しないデータにアクセスしようとしたときに発生する割込みで、内部割込みに分類される。

# 必要な冗長ビットは何ビットか

## 問題
メモリのエラー検出及び訂正にECCを利用している。データバス幅2のn乗ビットに対して冗長ビットがn＋2ビット必要なとき，128ビットのデータバス幅に必要な冗長ビットは何ビットか。

ア：7

イ：8

ウ：9

エ：10

## 解答
ウ

## 解説
まず、`2のn乗ビット`と`128ビット`との対応を考える。"128は2の何乗なのか"を考えると「128＝2の7乗」なので、`nは7`とわかる。冗長ビットは、2のn乗ビットに対して n＋2ビット必要なので、2の7乗＝128ビットのデータバス幅に必要な冗長ビットは「7＋2＝9ビット」となる。　したがって「ウ」が正解。

# 主記憶の実効アクセス時間
## 問題
A～Dを，主記憶の実効アクセス時間が短い順に並べたものはどれか。

![12](https://user-images.githubusercontent.com/115250897/233738010-b0cdf59f-eedf-49ff-bc66-94e08c4bedf7.gif)

ア：A,B,C,D

イ：A,D,B,C

ウ：C,D,A,B

エ：D,C,A,B

## 解答
イ

## 解説
CPUがメモリにアクセスするときは、まずは高速なキャッシュメモリへのアクセスを試み、キャッシュメモリに目的のデータがなかったときにだけ主記憶にアクセスする。キャッシュメモリに目的のデータがある確率がヒット率。

キャッシュメモリと主記憶が存在するとき、実際の1アクセスに要する平均時間を実効アクセス時間といい、以下の式で表すことができる。

```
(キャッシュメモリのアクセス時間×ヒット率)＋主記憶のアクセス時間×(1－ヒット率)
```

AとBはキャッシュメモリがないので、主記憶のアクセス時間＝実効アクセス時間。CとDの実効アクセス時間は次のように計算する。

- C：(20×0.6)＋(70×0.4)＝12＋28＝40
- D：(10×0.9)＋(80×0.1)＝9＋8＝17

したがって、4つを実効アクセス時間が短い順に並べると「A(15)，D(17)，B(30)，C(40)」となる。

# 最低何台停止すると縮退運転になるか
## 問題
仮想化マシン環境を物理マシン20台で運用しているシステムがある。次の運用条件のとき，物理マシンが最低何台停止すると縮退運転になるか。

〔運用条件〕
1. 物理マシンが停止すると，そこで稼働していた仮想マシンは他の全ての物理マシンで均等に稼働させ，使用していた資源も同様に配分する。
2. 物理マシンが20台のときに使用する資源は，全ての物理マシンにおいて70%である。
3. 1台の物理マシンで使用している資源が90%を超えた場合，システム全体が縮退運転となる。
4. 1～3以外の条件は考慮しなくてよい。

ア：2

イ：3

ウ：4

エ：5

## 解答
エ

## 解説
20台の物理マシン上でそれぞれ70%の資源が使用されているので、システムが稼働するために必要となる総資源量は、

```
　20台×70%＝1,400%
```

物理マシン1台の資源量を基準とすると1,400%（物理マシン14台分の資源）になる。x台の物理マシンが停止したとき、この資源量は残りの物理マシン数`20－x台`に均等に割り振られることになるので、各マシンの資源使用率を90%以下にするには、

```
　1,400÷(20－x)≦90
　1,400≦90(20－x)
　1,400≦1,800－90x
　90x≦400
　x≦4.444…台
```

最大で4台までの停止が許容できることになる。したがって、物理マシンの資源使用率が90%を超え縮退運転に移行するのは、停止台数が5台になった時点。

ちなみに自己流で求めた方法はもっと単純で、1,400（%）を90（%）で割ることで、15.555…（台）となるため、切り上げて16台は必要という結論。

# システムの稼働率
## 問題
図のように，1台のサーバ，3台のクライアント及び2台のプリンタがLANで接続されている。このシステムはクライアントからの指示に基づいて，サーバにあるデータをプリンタに出力する。各装置の稼働率が表のとおりであるとき，このシステムの稼働率を表す計算式はどれか。ここで，クライアントは3台のうちどれか1台でも稼働していればよく，プリンタは2台のうちどちらかが稼働していればよい。

![14](https://user-images.githubusercontent.com/115250897/233942287-a427aa34-5ca9-4a35-bfa3-12e704c5dae2.gif)

ア：abの3乗cの2乗

イ：a(1－bの3乗)(1－cの2乗)

ウ：a(1－b)の3乗(1－c)の2乗

エ：a(1－(1－b)の3乗)(1－(1－c)の2乗)


## 解答
エ

## 解説
複数機器で構成されているシステムの全体を計算するには、直列接続の稼働率および並列接続の稼働率を求める公式を使う。

### 直列接続の稼働率
稼働率がR1、R2である2つの機器があり、両方が稼働していなければシステムが停止してしまう場合の稼働率

```
R1×R2
```
 
### 並列接続の稼働率
稼働率がR1、R2である2つの機器があり、少なくとも一つが稼働していればシステムの稼働が継続する場合の稼働率

```
1－(1－R1)(1－R2)
```
 
設問のシステム構成を整理すると、最低限サーバ・クライアント・プリンタの各1台が稼働していれば、システムとしての稼働を続けられることがわかる。この様子を直列・並列が直感的にわかるように単純化して図解にすると次のようになる。

![14a](https://user-images.githubusercontent.com/115250897/233945115-bb0b2147-9bd7-400d-a6cb-0b1f3301c795.gif)

並列部分であるクライアント3台部分の稼働率は、
　
 ```
　1－(1－b)(1－b)(1－b)＝1－(1－b)の3乗
```

同様に並列部分であるプリンタ2台部分の稼働率は、

```
　1－(1－c)(1－c)＝1－(1－c)の2乗
```

サーバ・クライアント・プリンタのそれぞれの部分は直列接続になるので、システム全体としての稼働率は、

```
　a×(1－(1－b)の3乗)×(1－(1－c)の2乗)
＝a(1－(1－b)の3乗)(1－(1－c)の2乗)
```

したがって「エ」の式が適切。

# バッファサイズLを表す関係式
## 問題
図の送信タスクから受信タスクにT秒間連続してデータを送信する。1秒当たりの送信量をS，1秒当たりの受信量をRとしたとき，バッファがオーバフローしないバッファサイズLを表す関係式として適切なものはどれか。ここで，受信タスクよりも送信タスクの方が転送速度は速く，次の転送開始までの時間間隔は十分にあるものとする。

![15](https://user-images.githubusercontent.com/115250897/234169865-c2e2a9dd-89ea-491b-99b3-247be1f90b78.gif)

ア：L＜(R－S)×T

イ：L＜(S－R)×T

ウ：L≧(R－S)×T

エ：L≧(S－R)×T

## 解答
エ

## 解説
受信タスクの転送速度より送信タスクの転送速度が速いということは、バッファが`送出するデータ量よりも受け取るデータ量が多い`ということ。この状態だとバッファが抱えるデータ量が少しずつ増えていくことになり、やがてバッファの容量からあふれ`オーバフロー`が生じる可能性がある。

仮に、`送信が100バイト/秒`、`受信が80バイト/秒`の速度であったとすると、`1秒当たり20バイトがバッファに溜まる`ことになります。この20バイトは、送信タスクからの受信量(S)から受信タスクへの送信量(R)を引いたデータ量、すなわち`S－R`の式で表すことができる。さらに`S－R`が1秒当たりの滞留量なので、T秒間の連続送信中にバッファに溜まる最大データ量は`(S－R)×T`の式で表すことができる。

オーバフローを防ぐためには、バッファサイズ(L)にはこの数値以上を設定する必要がある。よって、Lが最大滞留量`(S－R)×T`以上であることを示す`L≧(S－R)×T`が適切な関係式とわかる。

# インタプリタの説明はどれか
## 問題
インタプリタの説明として，適切なものはどれか。

ア：原始プログラムを，解釈しながら実行するプログラムである。

イ：原始プログラムを，推論しながら翻訳するプログラムである。

ウ：原始プログラムを，目的プログラムに翻訳するプログラムである。

エ：実行可能なプログラムを，主記憶装置にロードするプログラムである。

## 解答
ア

## 解説
インタプリタは、人間がわかる`プログラミング言語`で書かれたコードを、コンピューターがわかる　`機械語`に解釈するフローを、プログラムの実行時に`1命令ずつ（1行ずつ）`実行するソフトウェアのこと。これに対して、あらかじめ機械語に`一括して翻訳する`ソフトウェアを`コンパイラ`という。

インタプリタ方式はコードの解釈と実行を交互におこなうため、コンパイラ方式と比較してプログラムの実行速度が遅くなる傾向がある。一方、様々な環境で実行できることや、バグを見つけやすいため、テストがおこないやすいという利点がある。

JavaScript、PHP、Pythonなどのプログラム言語がインタプリタ方式を採用している。CやJavaはコンパイラ方式。

ア：正しい。インタプリタの説明。

イ：トランスレータの説明。

ウ：コンパイラの説明。

エ：ローダの説明。

# 絶対パス名を説明したものはどれか
## 問題
ファイルシステムの絶対パス名を説明したものはどれか。

ア：あるディレクトリから対象ファイルに至る幾つかのパス名のうち，最短のパス名

イ：カレントディレクトリから対象ファイルに至るパス名

ウ：ホームディレクトリから対象ファイルに至るパス名

エ：ルートディレクトリから対象ファイルに至るパス名

## 解答
エ

## 解説
パス名は、ファイルシステム内のディレクトリやファイルの位置を示すもので、パスを指定する方法には「絶対パス」と「相対パス」の二つがある。

### 絶対パス
階層の最上位であるルートディレクトリを基点として、目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法

### 相対パス
現在作業を行っているカレントディレクトリを基点として、目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法

ア：あるディレクトリから別のディレクトリに至るパスは一つしかないので、最長・最短のパス名という概念は存在しない。

イ：相対パスの説明。

ウ：絶対パスの基点となるのはホームディレクトリではなく、ルートディレクトリ。なお、Linuxではホームディレクトリをチルダ(~)で表し、そこからの相対パスを指定する方法がある。

エ：正しい。絶対パスの説明。

# DRAMの特徴はどれか
## 問題
DRAMの特徴はどれか。

ア：書込み及び消去を一括又はブロック単位で行う。

イ：データを保持するためのリフレッシュ操作又はアクセス操作が不要である。

ウ：電源が遮断された状態でも，記憶した情報を保持することができる。

エ：メモリセル構造が単純なので高集積化することができ，ビット単価を安くできる。

## 解答
エ

## 解説
DRAM(Dynamic Random Access Memory)は、コンデンサに電荷を蓄えることにより情報を記憶し、電源供給が無くなると記憶情報も失われる揮発性。集積度を上げることが比較的簡単にできるためコンピュータの主記憶装置として使用されている。

![19](https://user-images.githubusercontent.com/115250897/235011786-5a3c620f-dff5-40c2-867f-25a309f9cd7b.gif)

ア：DRAMはアドレス単位で読み書きや消去をおこなう。

イ：SRAM(Static Random Access Memory)の説明。DRAMでは消えかけた電荷をコンデンサに充電するリフレッシュ動作を常に一定間隔で行うことでデータの保持をしている。

ウ：DRAMは揮発性メモリなので電源が途絶えると記憶内容も失われる。

エ：正しい。DRAMの説明。

# 論理チェック
## 問題
次のような注文データが入力されたとき，注文日が入力日以前の営業日かどうかを検査するチェックはどれか。

![20](https://user-images.githubusercontent.com/115250897/235278183-f2c34b33-e31b-4296-ba06-d76b989bf1ce.gif)

ア：シーケンスチェック

イ：重複チェック

ウ：フォーマットチェック

エ：論理チェック

## 解答
エ

## 解説
注文データは注文が決まった後に入力されるはずなので、注文日がデータ入力日よりも後の日付になることはない。同様に、貸出日が返却日より後の日付だったり、仕入数よりも販売数が多くなったりすることは起こり得ない。もし違っていれば入力されたデータが誤っているということ。

`論理チェック`は、このように複数の項目の関連から入力されたデータが論理的に矛盾していないかどうかを検証するもの。

ア：シーケンスチェックは、入力データが定められた順番に並んでいるかどうかを検証するもの。

イ：重複チェックは、入力データと同じデータが既に入力済みではないか(一意であるか)を検証するもの。

ウ：フォーマットチェックは、入力データの桁数や文字種などの書式や形式が定められた基準に従っているかを検証するもの。

エ：正しい。論理チェックは、関連のある項目の値に論旨的矛盾がないかどうかをチェックするもの。





