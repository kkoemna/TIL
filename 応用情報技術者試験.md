# 1ビット演算の応用
## 問題
0以上255以下の整数nに対して，

![01](https://github.com/kkoemna/til/assets/115250897/ccc48d48-fb49-4a69-aa2d-dad062fe4ef6)

と定義する。next(n)と等しい式はどれか。ここで，x AND y 及び x OR y は，それぞれxとyを2進数表現にして，桁ごとの論理積及び論理和をとったものとする。

```
ア：(n＋1) AND 255

イ：(n＋1) AND 256

ウ：(n＋1) OR 255

エ：(n＋1) OR 256
```

## 解答


## 解説
next(n)は、引数nが0～254の場合には引数に1を加えた値を返し、255では0を返します。

①　1ずつ加算がおこなわれるか。

②　next(255)のときに結果が 0 となるか。

この点を検証するためにnext(1)とnext(255)の結果をそれぞれ考えてみます。

```
ア：正しい。ビットマスクの255を2進数で表すと「11111111」で、このビット列との論理積(AND)は(n＋1)の下位8ビットだけを取り出すように作用します。引数が255の場合には、最上位ビットの演算結果が0になるので関数は0を返します。
![01a](https://github.com/kkoemna/til/assets/115250897/3da68099-26b2-4a9a-8692-900c79a8dc68)

イ：ビットマスクの256を2進数で表すと「1 00000000」です。どの引数を与えても下位8ビットの演算結果が常に0になってしまうため誤りです。
![01i](https://github.com/kkoemna/til/assets/115250897/7f003923-671c-4ebb-a45a-94bb3f7f36b2)

ウ：ビットマスクの255を2進数で表すと「11111111」で、このビット列と論理和(OR)演算を行った結果の下位8ビットは常に「11111111」になります。0≦n＜255では常に255、255では511が返るため誤りです。
![01u](https://github.com/kkoemna/til/assets/115250897/62b0a23e-2281-43e1-b6ab-aa883f76ab2d)

エ：ビットマスクの256を2進数で表すと「1 00000000」で、このビット列と論理和(OR)演算を行った結果の最上位ビットは常に1になります。どの引数を与えても常に256以上の値が返るため誤りです。
![01e](https://github.com/kkoemna/til/assets/115250897/47171d1e-2247-40d9-bf41-cc0479c4207e)
```

